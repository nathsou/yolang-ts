import std/foundations

type Sieve = {
  primes: i32[],
  count: u32,
}

fun init(mut sieve: Sieve): void {
  sieve.primes[0u32] = 2
  sieve.primes[1u32] = 3
  sieve.count = 1u32
}

fun isPrime(sieve: Sieve, n: i32): bool {
  mut i = 1u32

  while true {
    let p = sieve.primes[i]

    if p * p > n {
      return true
    }

    if n mod p == 0 {
      return false
    }

    i += 1u32
  }

  true
}

fun nextPrime(mut sieve: Sieve): i32 {
  mut n = sieve.primes[sieve.count] + 2
  
  while not sieve.isPrime(n) {
    n += 2
  }

  sieve.count += 1u32
  sieve.primes[sieve.count] = n

  n
}

fun fill(mut sieve: Sieve): void {
  let max = sieve.primes.len - 1u32
  while sieve.count < max {
    sieve.nextPrime()
  }
}

fun main() {
  mut sieve = Sieve {
    primes: [0; 1000000],
    count: 0u32
  }

  sieve.init()
  sieve.fill()

  log(sieve.primes.last())
}
