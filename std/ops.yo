#![noImplicitFoundationsImport]

type SInt = i8 | i32 | i64
type UInt = u8| u32 | u64
type Int = SInt | UInt

#meta(add)
pub fun +<T: Int>(a: T, b: T): T

#meta(sub)
pub fun -<T: Int>(a: T, b: T): T

#meta(neg)
pub fun -<T: SInt>(n: T): T

#meta(not)
pub fun not(q: bool): bool

#meta(mul)
pub fun *<T: Int>(a: T, b: T): T

#meta(signedDiv)
pub fun /<T: SInt>(a: T, b: T): T

#meta(unsignedDiv)
pub fun /<T: UInt>(a: T, b: T): T

#meta(mod)
pub fun mod<T: Int>(a: T, b: T): T

#meta(logicalAnd)
pub fun and(a: bool, b: bool): bool

#meta(logicalOr)
pub fun or(a: bool, b: bool): bool

pub fun nand(a: bool, b: bool): bool {
  not (a and b)
}

pub fun nor(a: bool, b: bool): bool {
  not (a or b)
}

pub fun xor(a: bool, b: bool): bool {
  (a or b) and (a nand b)
}

pub fun xnor(a: bool, b: bool): bool {
  (a nor b) or (a and b)
}

#meta(bitwiseAnd)
pub fun and<T: Int>(a: T, b: T): T

#meta(bitwiseOr)
pub fun or<T: Int>(a: T, b: T): T

#meta(signedLss)
pub fun <<T: SInt>(a: T, b: T): bool

#meta(unsignedLss)
pub fun <<T: UInt>(a: T, b: T): bool

#meta(signedLeq)
pub fun <=<T: SInt>(a: T, b: T): bool

#meta(unsignedLeq)
pub fun <=<T: UInt>(a: T, b: T): bool

#meta(signedGtr)
pub fun ><T: SInt>(a: T, b: T): bool

#meta(unsignedGtr)
pub fun ><T: UInt>(a: T, b: T): bool

#meta(signedGeq)
pub fun >=<T: SInt>(a: T, b: T): bool

#meta(unsignedGeq)
pub fun >=<T: UInt>(a: T, b: T): bool

#meta(eq)
pub fun ==<T: Int>(a: T, b: T): bool

#meta(neq)
pub fun !=<T: Int>(a: T, b: T): bool

#meta(neq)
pub fun !=(a: u32, b: u32): bool

#meta(neq)
pub fun !=(a: i64, b: i64): bool

#meta(neq)
pub fun !=(a: u64, b: u64): bool

pub fun even(n: i32): bool {
  n and 1 == 0
}

pub fun odd(n: i32): bool {
  n and 1 == 1
}

pub fun pow(a: i32, n: i32): i32 {
  if n == 0 {
    1
  } else {
    if n.even() {
      (a * a).pow(n / 2)
    } else {
      a * (a * a).pow((n - 1) / 2)
    }
  }
}

pub fun abs(x: i32): i32 {
  if x < 0 { -x } else { x }
}

#meta(u8FromSInt)
pub fun u8<T: SInt>(n: T): u8

#meta(u8FromUInt)
pub fun u8<T: UInt>(n: T): u8
