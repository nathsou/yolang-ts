#![noImplicitFoundationsImport]

#meta(add)
pub fun +(a: i32, b: i32): i32

#meta(add)
pub fun +(a: u32, b: u32): u32

#meta(add)
pub fun +(a: i64, b: i64): i64

#meta(add)
pub fun +(a: u64, b: u64): u64

#meta(sub)
pub fun -(a: i32, b: i32): i32

#meta(sub)
pub fun -(a: u32, b: u32): u32

#meta(sub)
pub fun -(a: i64, b: i64): i64

#meta(sub)
pub fun -(a: u64, b: u64): u64

#meta(neg)
pub fun -(n: i32): i32

#meta(neg)
pub fun -(n: i64): i64

#meta(not)
pub fun not(q: bool): bool

#meta(mul)
pub fun *(a: i32, b: i32): i32

#meta(mul)
pub fun *(a: u32, b: u32): u32

#meta(mul)
pub fun *(a: i64, b: i64): i64

#meta(mul)
pub fun *(a: u64, b: u64): u64

#meta(signedDiv)
pub fun /(a: i32, b: i32): i32

#meta(unsignedDiv)
pub fun /(a: u32, b: u32): u32

#meta(signedDiv)
pub fun /(a: i64, b: i64): i64

#meta(unsignedDiv)
pub fun /(a: u64, b: u64): u64

#meta(mod)
pub fun mod(a: i32, b: i32): i32

#meta(mod)
pub fun mod(a: u32, b: u32): u32

#meta(mod)
pub fun mod(a: i64, b: i64): i64

#meta(mod)
pub fun mod(a: u64, b: u64): u64

#meta(logicalAnd)
pub fun and(a: bool, b: bool): bool

#meta(logicalOr)
pub fun or(a: bool, b: bool): bool

pub fun nand(a: bool, b: bool): bool {
  not (a and b)
}

pub fun nor(a: bool, b: bool): bool {
  not (a or b)
}

pub fun xor(a: bool, b: bool): bool {
  (a or b) and (a nand b)
}

pub fun xnor(a: bool, b: bool): bool {
  (a nor b) or (a and b)
}

#meta(bitwiseAnd)
pub fun and(a: i32, b: i32): i32

#meta(bitwiseAnd)
pub fun and(a: u32, b: u32): u32

#meta(bitwiseAnd)
pub fun and(a: i64, b: i64): i64

#meta(bitwiseAnd)
pub fun and(a: u64, b: u64): u64

#meta(bitwiseOr)
pub fun or(a: i32, b: i32): i32

#meta(bitwiseOr)
pub fun or(a: u32, b: u32): u32

#meta(bitwiseOr)
pub fun or(a: i64, b: i64): i64

#meta(bitwiseOr)
pub fun or(a: u64, b: u64): u64

#meta(signedLss)
pub fun <(a: i32, b: i32): bool

#meta(unsignedLss)
pub fun <(a: u32, b: u32): bool

#meta(signedLss)
pub fun <(a: i64, b: i64): bool

#meta(unsignedLss)
pub fun <(a: u64, b: u64): bool

#meta(signedLeq)
pub fun <=(a: i32, b: i32): bool

#meta(unsignedLeq)
pub fun <=(a: u32, b: u32): bool

#meta(signedLeq)
pub fun <=(a: i64, b: i64): bool

#meta(unsignedLeq)
pub fun <=(a: u64, b: u64): bool

#meta(signedGtr)
pub fun >(a: i32, b: i32): bool

#meta(unsignedGtr)
pub fun >(a: u32, b: u32): bool

#meta(signedGtr)
pub fun >(a: i64, b: i64): bool

#meta(unsignedGtr)
pub fun >(a: u64, b: u64): bool

#meta(signedGeq)
pub fun >=(a: i32, b: i32): bool

#meta(unsignedGeq)
pub fun >=(a: u32, b: u32): bool

#meta(signedGeq)
pub fun >=(a: i64, b: i64): bool

#meta(unsignedGeq)
pub fun >=(a: u64, b: u64): bool

#meta(eq)
pub fun ==(a: i32, b: i32): bool

#meta(eq)
pub fun ==(a: u32, b: u32): bool

#meta(eq)
pub fun ==(a: i64, b: i64): bool

#meta(eq)
pub fun ==(a: u64, b: u64): bool

#meta(neq)
pub fun !=(a: i32, b: i32): bool

#meta(neq)
pub fun !=(a: u32, b: u32): bool

#meta(neq)
pub fun !=(a: i64, b: i64): bool

#meta(neq)
pub fun !=(a: u64, b: u64): bool

pub fun even(n: i32): bool {
  n and 1 == 0
}

pub fun odd(n: i32): bool {
  n and 1 == 1
}

pub fun pow(a: i32, n: i32): i32 {
  if n == 0 {
    1
  } else {
    if n.even() {
      (a * a).pow(n / 2)
    } else {
      a * (a * a).pow((n - 1) / 2)
    }
  }
}

pub fun abs(x: i32): i32 {
  if x < 0 { -x } else { x }
}

#meta(u8FromInt)
pub fun u8(n: i32): u8
