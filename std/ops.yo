#![noImplicitFoundationsImport]

#meta
pub fun `+`<T in [i8, u8, i16, u16, i32, u32, i64, u64, i128, u128]>(a: T, b: T): T

#meta(sub)
pub fun `-`<T in [i8, u8, i16, u16, i32, u32, i64, u64, i128, u128]>(a: T, b: T): T

#meta(neg)
pub fun `-`<T in [i8, i16, i32, i64, i128]>(n: T): T

pub fun not(q: bool): bool {
  if q { false } else { true }
}

#meta
pub fun `*`<T in [i8, u8, i16, u16, i32, u32, i64, u64, i128, u128]>(a: T, b: T): T

#meta(signedDiv)
pub fun `/`<T in [i8, i16, i32, i64, i128]>(a: T, b: T): T

#meta(unsignedDiv)
pub fun `/`<T in [u8, u16, u32, u64, u128]>(a: T, b: T): T

#meta(mod)
pub fun mod<T in [i8, u8, i16, u16, i32, u32, i64, u64, i128, u128]>(a: T, b: T): T

pub fun xor(a: bool, b: bool): bool {
  (a or b) and (a nand b)
}

pub fun xnor(a: bool, b: bool): bool {
  (a nor b) or (a and b)
}

// bitwise not
#meta
pub fun `~`<T in [i8, u8, i16, u16, i32, u32, i64, u64, i128, u128]>(q: T): T

// bitwise and
#meta
pub fun `&`<T in [i8, u8, i16, u16, i32, u32, i64, u64, i128, u128]>(a: T, b: T): T

// bitwise or
#meta
pub fun `|`<T in [i8, u8, i16, u16, i32, u32, i64, u64, i128, u128]>(a: T, b: T): T

// bitwise xor
#meta
pub fun `^`<T in [i8, u8, i16, u16, i32, u32, i64, u64, i128, u128]>(a: T, b: T): T

// left shift
#meta
pub fun `<<`<T in [i8, u8, i16, u16, i32, u32, i64, u64, i128, u128]>(a: T, b: T): T

// right shift
#meta(arithmeticShiftRight)
pub fun `>>`<T in [i8, i16, i32, i64, i128]>(a: T, b: T): T

#meta(logicalShiftRight)
pub fun `>>`<T in [u8, u16, u32, u64, u128]>(a: T, b: T): T

#meta(signedLss)
pub fun `<`<T in [i8, i16, i32, i64, i128]>(a: T, b: T): bool

#meta(unsignedLss)
pub fun `<`<T in [u8, u16, u32, u64, u128]>(a: T, b: T): bool

#meta(signedLeq)
pub fun `<=`<T in [i8, i16, i32, i64, i128]>(a: T, b: T): bool

#meta(unsignedLeq)
pub fun `<=`<T in [u8, u16, u32, u64, u128]>(a: T, b: T): bool

#meta(signedGtr)
pub fun `>`<T in [i8, i16, i32, i64, i128]>(a: T, b: T): bool

#meta(unsignedGtr)
pub fun `>`<T in [u8, u16, u32, u64, u128]>(a: T, b: T): bool

#meta(signedGeq)
pub fun `>=`<T in [i8, i16, i32, i64, i128]>(a: T, b: T): bool

#meta(unsignedGeq)
pub fun `>=`<T in [u8, u16, u32, u64, u128]>(a: T, b: T): bool

#meta
pub fun `==`<T in [i8, u8, i16, u16, i32, u32, i64, u64, i128, u128]>(a: T, b: T): bool

#meta
pub fun `!=`<T in [i8, u8, i16, u16, i32, u32, i64, u64, i128, u128]>(a: T, b: T): bool

pub fun even<T in [i8, u8, i16, u16, i32, u32, i64, u64, i128, u128]>(n: T): bool {
  n & 1 == 0
}

pub fun odd<T in [i8, u8, i16, u16, i32, u32, i64, u64, i128, u128]>(n: T): bool {
  n & 1 == 1
}

// exponentiation
pub fun `**`<T in [i8, u8, i16, u16, i32, u32, i64, u64, i128, u128]>(a: T, n: T): T {
  if n == 0 {
    1
  } else {
    if n.even() {
      (a * a) ** (n / 2)
    } else {
      (a * (a * a)) ** ((n - 1) / 2)
    }
  }
}

pub fun abs<T in [i8, i16, i32, i64, i128]>(x: T): T {
  if x < 0 { -x } else { x }
}

pub fun abs<T in [u8, u16, u32, u64, u128]>(x: T): T {
  x
}

#meta(u8FromInt)
pub fun u8<T in [i8, i16, i32, i64, i128]>(n: T): u8

#meta(u8FromUInt)
pub fun u8<T in [u8, u16, u32, u64, u128]>(n: T): u8
